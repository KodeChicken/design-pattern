###一、原则
#####1.单一职责
#####2.接口隔离
#####3.依赖倒置
#####4.里氏替换
#####5.开闭原则
#####6.迪米特法则
#####7.合成服用原则


###二、设计模式
#####1.创建型模式：
单例模式、工厂模式、抽象工厂模式、原型模式、建造者模式。
#####2.结构型模式：
适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
#####1.行为型模式：
模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式



###三、模式详解
####单例模式
#####1.饿汉式-静态常量    SingletonTest01
优点：类加载的时候完成实例化，避免了多线程同步问题

缺点：未达到Lazy Loading的目的，如果从未使用过该实例，会造成内存的浪费

#####2.饿汉式-静态代码块    SingletonTest02
优点：类加载的时候完成实例化，避免了多线程同步问题

缺点：未达到Lazy Loading的目的，如果从未使用过该实例，会造成内存的浪费

#####3.懒汉式-线程不安全    SingletonTest03
优点：达到Lazy Loading的目的，但是只能在单线程下使用

缺点：多线程下是不安全的，可能会产生多个实例对象，所以多线程环境下不可用

结论：实际开发中，不使用该方式

#####4.懒汉式-线程安全，同步方法    SingletonTest04
优点：达到Lazy Loading的目的，能在多线程环境下使用

缺点：串行调用方法，效率太低，每个线程调用该同步方法会加锁，而该方法只需要执行一次实例化之后，不需要再被锁住。

结论：实际开发中，不推荐该方式

#####5.懒汉式-线程不安全，同步代码块    SingletonTest05
优点：达到Lazy Loading的目的

缺点：线程不安全

结论：实际开发中，不能使用该方式

#####6.双重检查    SingletonTest06(使用volatile关键字)
优点：达到Lazy Loading的目的，使用了两次非空判断，保证了线程安全，同时也避免了方法的反复同步问题

结论：实际开发中，推荐使用该方式

参考博客：https://www.cnblogs.com/quzhongren/p/11383998.html

#####7.静态内部类    
优点：线程安全，利用静态内部类特点实现延迟加载，效率高  

原理：使用类装载机制保证初始化实例时只有一个线程。
静态内部类不会随着外部类的加载而加载，
只有静态内部类的静态成员被调用时才会进行加载，
这样既保证的惰性初始化(Lazy-Initialazation)，
又由JVM保证了多线程并发访问的正确性。  

结论：实际开发中，推荐使用该方法

为什么静态内部类的单例模式是线程安全的?

参考博客：https://blog.csdn.net/ren421259121/article/details/89947692

#####6.枚举
优点：线程安全，防止反序列化重新创建新的对象，利用了JDK1.5的枚举实现单例模式

结论：实际开发中，推荐使用该方法

关于枚举用法，参考博客：https://blog.csdn.net/qq_39949109/article/details/80432477




